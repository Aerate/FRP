module VectorTypes where

open import Nat
open import postulates
open import BooleanTypes

data Vector (A : Set) : â„• â†’ Set where
  [] : Vector A 0
  _::_ : {n : â„•} â†’ A â†’ Vector A n â†’ Vector A (n + 1)

-- operations on Vectors
-----------------------

infixr 5 _::_

--only works with Vecs min 1, no base case
head : {A : Set} â†’ {n : â„•} â†’ Vector A (suc n) â†’ A
head (x :: _) = x

tail : {A : Set} â†’ {n : â„•} â†’ Vector A (suc n) â†’ Vector A n
tail (_ :: xs) = xs

[_]Vec : âˆ€ {A : Set} â†’ A â†’ Vector A 1
[ x ]Vec = x :: []

nats : (n : â„•) â†’ Vector â„• (n + 1)
nats 0 = 0 :: []
nats (suc n) = (suc n) :: nats n

map : {A B : Set} â†’ (f : A â†’ B) â†’ {n : â„•} â†’ Vector A n â†’ Vector B n
map f [] = []
map f (x :: xs) = f x :: (map f xs)

posnats : {n : â„•} â†’ tail (nats (suc n)) â‰¡ map suc (nats n)
posnats rewrite = refl

-- by autogive; y u no decomposition??
length : {A : Set} â†’ {n : â„•} â†’ Vector A n â†’ â„•
length = Î» {A} {n} _ â†’ n

-- compiles, but is broken (?)
length2 : (A : Set) â†’ (n : â„•) â†’ Vector A n â†’ â„•
length2 = Î» A n _ â†’ n

-- but needs actual count of elements
length3 : {A : Set} â†’ {n : â„•} â†’ Vector A n â†’ â„•
length3 [] = 0
length3 (x :: xs) = 1 + (length3 xs)

-- Tests
l1 : Vector ğ”¹ 1
l1 = tt :: []

l2 : Vector ğ”¹ 0
l2 = []

l3 : Vector ğ”¹ 3
l3 = tt :: tt :: ff :: []

l4 : Vector â„• 3
l4 = 1 :: 2 :: 3 :: []
